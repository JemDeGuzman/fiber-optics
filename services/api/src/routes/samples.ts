// services/api/src/routes/samples.ts
import { Router, Request, Response } from "express";
import multer from "multer";
import path from "path";
import fs from "fs";
import { PrismaClient } from '../generated/client';
import { updateSample, deleteSample, deleteManySamples } from "../controllers/batchController";

const router = Router();
const prisma = new PrismaClient();

type MulterRequest<TFile = Express.Multer.File> = Omit<Request, "file"> & {
  file?: TFile;
};

type MulterArrayRequest = Omit<Request, "files"> & {
  files?: Express.Multer.File[];
};

/* ------------------------ Upload config ------------------------ */
const UPLOAD_DIR = path.resolve(__dirname, "../../../uploads");
//console.log("MULTER UPLOAD_DIR ->", UPLOAD_DIR);
if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR, { recursive: true });

const storage = multer.diskStorage({
  destination: (_req, _file, cb) => cb(null, UPLOAD_DIR),
  filename: (_req, file, cb) => {
    const ext = path.extname(file.originalname) || ".jpg";
    const basename = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    cb(null, basename + ext);
  },
});

const upload = multer({
  storage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10 MB
  fileFilter: (_req, file, cb) => {
    // Accept image MIME types (jpeg, jpg, png) or any file since we trust the capture server
    if (/^image\//.test(file.mimetype) || file.mimetype.includes('image')) {
      cb(null, true);
    } else {
      // Still allow files even if MIME type doesn't indicate image (some servers send application/octet-stream)
      // since these are generated by our trusted test.py script
      cb(null, true);
    }
  },
});

/**
 * POST /api/samples/upload
 * multipart/form-data:
 *  - files (required, one or more image files)
 *  - batchId (required)
 *  - classification, luster_value, roughness, tensile_strength (optional)
 *  - capturedAt (optional)
 */
// Accept multiple files with flexible field name handling
// Use .any() to accept files from any field name
router.post("/upload", upload.any(), async (req: Request, res: Response) => {
  type MulterAnyRequest = Omit<Request, "files"> & {
    files?: Express.Multer.File[];
  };
  const r = req as MulterAnyRequest;

  try {
    // safe access to files
    const uploadedFiles = r.files;
    console.log("[UPLOAD] Received request");
    console.log("[UPLOAD] Number of files:", uploadedFiles?.length ?? 0);
    if (uploadedFiles && uploadedFiles.length > 0) {
      console.log("[UPLOAD] File names:", uploadedFiles.map(f => f.originalname));
      console.log("[UPLOAD] Field names:", uploadedFiles.map(f => f.fieldname));
    }
    
    if (!uploadedFiles || uploadedFiles.length === 0) {
      return res.status(400).json({ error: "No files uploaded (field name must be 'file')" });
    }

    const {
      batchId,
      classification,
      luster_value,
      roughness,
      tensile_strength,
      capturedAt,
    } = req.body;

    if (!batchId) {
      // cleanup if files exist
      try {
        uploadedFiles.forEach(file => {
          if (file && file.path && fs.existsSync(file.path)) {
            fs.unlinkSync(file.path);
          }
        });
      } catch (e) {}
      return res.status(400).json({ error: "batchId is required" });
    }

    // verify batch exists:
    const batch = await prisma.dataBatch.findUnique({ where: { id: Number(batchId) } });
    if (!batch) {
      try {
        uploadedFiles.forEach(file => {
          if (file && file.path && fs.existsSync(file.path)) {
            fs.unlinkSync(file.path);
          }
        });
      } catch (e) {}
      return res.status(400).json({ error: "batchId not found" });
    }

    // Build URLs and file mappings for all uploaded images
    const protocol = req.protocol;
    const host = req.get("host"); // e.g. localhost:4000
    
    // Map each file to its URL and original filename
    const imageData = uploadedFiles.map(file => ({
      fileName: file.originalname,
      imageUrl: `${protocol}://${host}/uploads/${file.filename}`,
    }));
    
    console.log("[UPLOAD] Image data prepared:", imageData.length, "images");
    console.log("[UPLOAD] Image data:", JSON.stringify(imageData, null, 2));

    // Create ONE DataSample record with metadata
    // Create ONE ImageCapture per file with onDelete: Cascade
    const sample = await prisma.dataSample.create({
      data: {
        batchId: Number(batchId),
        image_capture: imageData[0].imageUrl, // keep first URL for backward compatibility
        images: {
          createMany: {
            data: imageData,
          },
        },
        classification: classification ?? "unknown",
        luster_value: luster_value ? parseFloat(luster_value) : undefined,
        roughness: roughness ? parseFloat(roughness) : undefined,
        tensile_strength: tensile_strength ? parseFloat(tensile_strength) : undefined,
        createdAt: capturedAt ? new Date(capturedAt) : undefined,
      },
      include: {
        images: true,
      },
    });

    console.log("[UPLOAD] Sample created with ID:", sample.id);
    console.log("[UPLOAD] Images stored:", sample.images.length);

    return res.json({ ok: true, sample, uploadedFileCount: uploadedFiles.length });
  } catch (err: any) {
    console.error("samples.upload error:", err);

    // attempt to cleanup uploaded files on error
    try {
      const uploadedFiles = (req as MulterAnyRequest).files;
      if (uploadedFiles) {
        uploadedFiles.forEach(file => {
          if (file && file.path && fs.existsSync(file.path)) {
            fs.unlinkSync(file.path);
          }
        });
      }
    } catch (cleanupErr) {
      console.warn("cleanup error:", cleanupErr);
    }

    return res.status(500).json({ error: "Upload failed", details: String(err.message ?? err) });
  }
});

/* ---------------------- existing sample routes ---------------------- */
// PATCH /api/samples/:id
router.patch("/:id", updateSample);

// DELETE /api/samples/:id
router.delete("/:id", deleteSample);

// DELETE Many /api/samples/deleteMany
router.post("/deleteMany", deleteManySamples);

export default router;
